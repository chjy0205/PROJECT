---
title: "R Notebook"
output:
  pdf_document: default
  html_notebook: default
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
# Get demographic data from community report
```{r}
community=read.csv('https://github.com/chjy0205/data/raw/master/Community%20Reporting%20Areas.csv',stringsAsFactors = F)
```
# Verify data types
```{r}
str(community)
```
# Univariate data analysis
# Centrality
```{r}
summary(community$Median.household.income..dollars.)
```
# Dispersion
```{r}
library(moments)
sd(community$Median.household.income..dollars.,na.rm= T)
sd(community$Median.household.income..dollars.,na.rm =T)/mean(community$Median.household.income..dollars.,na.rm =T)
```
# Skewness
```{r}
skewness(community$Median.household.income..dollars.,na.rm=T)
```
# Kurtosis
```{r}
kurtosis(community$Median.household.income..dollars.,na.rm = T)

data=community[is.finite(community$Median.household.income..dollars.),]
var=data$Median.household.income..dollars.
mnVar=mean(var,na.rm = T)
sdVar=sd(var,na.rm = T)

library(ggplot2)

base=ggplot(data, aes(x=var))
hist = base + geom_histogram(fill="green", 
                             color='grey',
                          aes(y=..density..))
histAndNormal = hist + stat_function(fun=dnorm,
                                     color="red",
                                     args=list(mean=mnVar,sd=sdVar))

histAndNormal
```

```{r}
mdVar=median(var)
histAndNormal + geom_vline(aes(xintercept = mnVar,colour="mean"),
                           show.legend  = TRUE) + 
                geom_vline(aes(xintercept = mdVar,colour="median"),
                           show.legend  = TRUE) + 
                scale_color_manual(name = "centrals", 
                                   values = c(median = "blue", mean = "red"))
```

# Clustering
```{r}
length(community$Community.Reporting.Area.Name)==length(unique(community$Community.Reporting.Area.Name))

row.names(community)=community$Community.Reporting.Area.Name

str(community[,c(11,15,21)])

library(cluster)
incoSimi=daisy(community[,c(11,15,21)],metric = "euclidean",
               stand=TRUE)
incoClus=hclust(incoSimi,method = 'average')
plot(incoClus,cex=0.5)

plot(incoClus,cex=0.3)
rect.hclust(incoClus, k = 3,border = c('orange','blue','red'))
```


# Linear Regression
### Check the data
```{r}
hist(community$Median.household.income..dollars.)
```
### Verify that each variable in X has a linear relationship with Y.
```{r}
explanans=names(community)[c(11,15)]
for (x in explanans){
    par=cbind(community[,x],community$Median.household.income..dollars.)
    p=cor.test(community[,x],community$Median.household.income..dollars.)
    print(paste("Pearson:",p$estimate," - Is significative?",p$p.value<0.05))
}
```
### Check the correlation between each pair of X variables.
```{r}
cor(community[explanans])
```
### Set the row names with the community names.
```{r}
row.names(community)=community$Community.Reporting.Area.Name
```
### Request a linear regression model and check the detailed result.
```{r}
LinRegINCOME=lm(community$Median.household.income..dollars.~ Percent.of.Population.of.Color + Percent.Bachelor.degree.or.higher, data = community)

summary(LinRegINCOME)
```
### Regression of income and percent population of color
```{r}
LinRegINCOME1=lm(community$Median.household.income..dollars.~Percent.of.Population.of.Color, data=community)
summary(LinRegINCOME1)
```
### Regression of income and percent bachelor degree or higher
```{r}
LinRegINCOME2=lm(community$Median.household.income..dollars.~Percent.Bachelor.degree.or.higher, data=community)
summary(LinRegINCOME2)
```
### Regression of degree and population of color
```{r}
LinRegINCOME3=lm(community$Percent.Bachelor.degree.or.higher~Percent.of.Population.of.Color, data=community)
summary(LinRegINCOME3)
```

# Map
```{r}
(maps=list.files(pattern = 'shp'))

library(rgdal)
SeattleMap <- rgdal::readOGR("Neighborhoods.shp",stringsAsFactors=F)


```
## Merge two tables
```{r}
str(SeattleMap$S_HOOD)
str(community$Community.Reporting.Area.Name)

MSeattleMap=merge(SeattleMap,community, by.x='S_HOOD', by.y='Community.Reporting.Area.Name',all.x=F)
nrow(MSeattleMap)
```

```{r}
plot(SeattleMap, col='black')
plot(MSeattleMap, col='pink',border='grey',add=T)
```
## Define the input
```{r}
library(RColorBrewer)
library(classInt)
varToPlot=MSeattleMap$Percent.of.Population.of.Color
varToPlot2=MSeattleMap$Percent.Bachelor.degree.or.higher
varToPlot3=MSeattleMap$Median.household.income..dollars.
```
## Get colors and intervals
```{r}
numberOfClasses = 3
colorForScale='YlGnBu'
colors = brewer.pal(numberOfClasses, colorForScale)
intervals <- classIntervals(varToPlot, numberOfClasses, 
                            style = "quantile",
                            dataPrecision=2)
colorPallette <- findColours(intervals, colors)
```
## Plot variable1
```{r}
legendText="Population of color in Percent"
shrinkLegend=0.6
title="Population of color in Percent in Seattle 2013"

plot(SeattleMap,col='grey',border='white',main=title)
plot(MSeattleMap, col = colorPallette,border='grey',add=T)

legend('topright', legend = names(attr(colorPallette, "table")), 
       fill = attr(colorPallette, "palette"), cex = shrinkLegend, 
       bty = "n",
       title=legendText)
```
## Plot variable2
```{r}

numberOfClasses = 3
colorForScale='YlGnBu'
colors = brewer.pal(numberOfClasses, colorForScale)
intervals <- classIntervals(varToPlot2, numberOfClasses, 
                            style = "quantile",
                            dataPrecision=2)
colorPallette <- findColours(intervals, colors)


legendText="Bachelor Degree or higher in Percent"
shrinkLegend=0.6
title="Population with bachelor degree or higher in Seattle 2013"

plot(SeattleMap,col='grey',border='white',main=title)
plot(MSeattleMap, col = colorPallette,border='grey',add=T)

legend('topright', legend = names(attr(colorPallette, "table")), 
       fill = attr(colorPallette, "palette"), cex = shrinkLegend, 
       bty = "n",
       title=legendText)
```
## Plot variable3
```{r}
numberOfClasses = 3
colorForScale='YlGnBu'
colors = brewer.pal(numberOfClasses, colorForScale)
intervals <- classIntervals(varToPlot3, numberOfClasses, 
                            style = "quantile",
                            dataPrecision=2)
colorPallette <- findColours(intervals, colors)


legendText="Median income in dollar"
shrinkLegend=0.6
title="Median income in Seattle 2013"

plot(SeattleMap,col='grey',border='white',main=title)
plot(MSeattleMap, col = colorPallette,border='grey',add=T)

legend('topright', legend = names(attr(colorPallette, "table")), 
       fill = attr(colorPallette, "palette"), cex = shrinkLegend, 
       bty = "n",
       title=legendText)
```

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
